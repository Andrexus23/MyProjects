###Описание способа фильтрации
В написанном скрипте test_task.js реализована
функция ***requiredRanges(element, range)***, которая является
функцией-предикатом  для проверки каждого элемента массива объектов и передаётся в метод filter.
Если функция возвращает true, то элемент остаётся в массиве, если false, то удаляется.

Предполагается, что null справа/слева говорит о неограниченности с той
или иной стороны соответственно. Тогда в requiredRanges правая или левая
граница удовлетворяет условию фильтрации, если диапазон с правой или левой 
стороны соответственно равен null. Если же диапазон отличен от null, то проверяется, что левая граница цены элемента не равна
null И левая граница цены элемента >= левого диапазона. Аналогично: проверяется, что правая граница цены элемента не равна null И правая граница цены 
элемента >= правого 
диапазона. Если оба условия (для левого и правого)
выполнены, функция возвращает true и элемент остаётся в новом массиве. Иначе удаляется.

***requiredRanges(element, range)*** в качестве первого аргумента принимает элемент массива,
в качестве второго - желаемый диапазон.

### Описание сортировки по цене

Для самой сортировки использован встроенный метод Array.prototype.sort().
Было решено отфильтровать по цене следующим образом.
Первый приоритет - левая граница; Второй приоритет - правая граница.
sort() вызывается у массива и принимает на вход компаратор, который нужно реализовать.
Компараторы были реализованы в виде стрелочных функций и описаны при передаче в sort().

**По возрастанию правой границы**

Если правая граница у элемента равна null, то он устанавливается выше по приоритету.
Числовые значения - по возрастанию.

После этого производится сортировка относительно левой границы.

**По возрастанию левой границы**

Если левая граница у элемента равна null, то он устанавливается ниже по приоритету.
Числовые значения - по возрастанию.

### Краткое описание алгоритма быстрой сортировке по левой границе цены

Алгоритм быстрой сортировки (рекурсивный) реализован вручную. 
Он сортирует массив курсов по возрастанию левой границы.
Берем произвольный элемент массива, разбиваем остальные элементы на “больше” (greater) и “меньше либо равно” (leq) 
по некоторому критерию (относительно контрольного элемента currentItem) и рекурсивно производим ту же самую 
сортировку над каждым из полученных множеств. Функция возвращает уже отсортированный массив.

- Сложность алгоритма быстрой сортировки по времени (в среднем и лучшем случаях): O(nlog(n));
- Сложность алгоритма быстрой сортировки по времени (в худшем случае): O(n^2);

Встроенный sort работает быстрее, чем вручную написанный алгоритм, потому что qSort() - алгоритм на javascript, в то время как встроенный написан на С++ и является низкоуровневым.

- Реализованный алгоритм быстрой сортировки: sort_by_price.js;
- Базовое тестовое задание с функцией, задающей условия фильтрации, фильтрацией и сортировкой 
встроенной функцией: test_task.js;
- Пример выходных данных для sort_by_price.js: sort_by_price_output
- Пример выходных данных для test_task.js: test_task_output
